{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"InterLab User Guide","text":"<p>InterLab, a research-focused toolkit created to facilitate study and experimentation in the realm of agent interactions, particularly those based on Language Learning Models (LLMs). Our primary objective is to simplify the process of crafting, deploying, and inspecting complex and structured queries within the context of agent interactions, while also providing robust support for interaction logging, UI and visualization. While we maintain a broad scope and plan to include game theoretic agents and a variety of scenarios, our main emphasis lies in the sphere of LLM interactions.</p>"},{"location":"installation/","title":"Getting started","text":""},{"location":"installation/#installation-via-poetry-recommended","title":"Installation via Poetry (recommended)","text":"<p>This repository utilizes poetry for package management, which is recommended for dependency installation and is mandatory for InterLab development. Poetry automatically generates and manages a virtual environment for you, and also installs <code>interlab</code> module itself. If you have poetry installed, running the following command will install InterLab:</p> <pre><code>poetry install\n</code></pre>"},{"location":"installation/#installation-via-pip-alternative","title":"Installation via <code>pip</code> (alternative)","text":"<p>Alternatively, <code>pip</code> can be used to install dependencies with <code>pip install -r requirements.txt</code> (core requirements) or <code>pip install -r requirements-full.txt</code> (including development tools, Jupyter Lab, etc.; equivalent to <code>poetry install</code>).</p> <p>Please note, when using <code>pip</code>, you're responsible for managing any virtual environments and deciding where packages should be installed.</p>"},{"location":"installation/#running-jupyter-lab","title":"Running Jupyter Lab","text":"<p>Jupyter Lab provides the simplest way to interact with the code and design experiments:</p> <pre><code>poetry run jupyter lab\n# Or without poetry, in the project root folder:\njupyter lab\n</code></pre> <p>After running the command, open the provided link in your browser. <code>notebooks/car_negotiation.ipynb</code> is a recommended starting point.</p>"},{"location":"installation/#google-colab","title":"Google Colab","text":"<p>Google Colab often offers a lightweight alternative to setting up InterLab locally on your computer. Interlab comes with built-in colab compatibility and we have prepared a Template InterLab Colab notebook with common setup and a simple example experiment with two LLMs interacting on behalf of their users.</p>"},{"location":"installation/#note-api-keys","title":"Note: API Keys","text":"<p>In order to use LLM provider serveics and APIs, you need to generate and provide the corresponding API keys. You can provide the keys as environment variables, via <code>.env</code> file, or interactively on every run (e.g. in the colab). Storing keys in the notebook is possible but not recommended (as they easily leak into git or while sharing the code).</p> <p>API keys can be stored in a <code>.env</code> file located in the notebook directory or your home directory. (This file is ignored by <code>git</code> by default, providing an additional security measure.) The file is a simple text file with key=value pairs, for example:</p> <pre><code>OPENAI_API_KEY=sk-...\nOPENAI_API_ORG=org-...\nANTHROPIC_API_KEY=sk-ant-...\n...\n</code></pre> <p>You can then import these variables from the <code>.env</code> file into a Jupyter notebook using the dotenv package:</p> <pre><code>import dotenv\ndotenv.load_dotenv()\n</code></pre>"},{"location":"overview/","title":"Overview","text":"<p>At its core, InterLab offers three fundamental layers, each tailored to seamlessly support different aspects of your research experiments:</p>"},{"location":"overview/#base-layer","title":"Base Layer","text":"<p>Base layer serves as the foundation, our base layer presents a generic environment tailored for experimental design. Key features include:</p> <ul> <li>Contexts: Easy monitoring with auto-logged actions structured in a tree format. Our web context explorer enhances visibility, allowing users to delve deeper on-demand. Additionally, this layer offers a dynamic inspection of ongoing experiments which is quite handy for tracking progress and making timely decisions, such as halting an experiment if necessary.</li> <li>Storage: Benefit from a hassle-free experience with automatic data management for saving and retrieving experimental work.</li> <li>LLM Queries: Simplify interactions with language models through our querying API that intelligently structures responses into Python data structures.</li> </ul>"},{"location":"overview/#actor-layer","title":"Actor Layer","text":"<p>At this level, we introduce the concept of an \"Actor\", a fundamental entity equipped with two key operations: \"observe\" and \"query\". The \"observe\" function enriches an Actor's memory without yielding a direct return output. Conversely, \"query\" solicits a response from the Actor, seeking information on potential actions or internal state assessments. For instance, envision an Actor designed for playing tic-tac-toe: the \"observe\" operation records the moves, while a \"query\" might request the next best move as 'circle'. InterLab provides you with the framework to customize your own Actor, along with standard implementations suited for typical scenarios, including a one-shot LLM Actor and a chain-of-thought Actor with memory variants ListMemory (remembers everything), SummarizingMemory (summarize events), and AssociativeMemory (recall events related to a query). The Actor layer integrates with the base, ensuring that both observations and queries are systematically logged into the context tree. We also offer an interactive web console actor, empowering you to step in as an Actor and steer experiments in real-time as needed. Environment Layer: This layer represents an abstract canvas that encapsulates a scenario's state, facilitating the progression to a subsequent step. In this versatile sphere, users are free to introduce their custom environments, while we also provide standard settings such as those for matrix games or negotiation environments.</p>"},{"location":"overview/#environment-layer","title":"Environment Layer","text":"<p>Environment layer represents an abstract canvas that encapsulates a scenario's state, facilitating the progression to a subsequent step. In this versatile sphere, users are free to introduce their custom environments, while we also provide standard settings such as those for matrix games or negotiation environments.</p>"},{"location":"overview/#schema","title":"Schema","text":""},{"location":"contexts/basics/","title":"Contexts","text":"<p>InterLab Contexts are a framework for logging, tracing, storing results and and visualisation of nested computations and actor interactions. They are designed to support large textual and structured (e.g. JSON) inputs and outputs, as well as generic and custom visualisations. custom visualisations.</p> <p>An instance of Context is a core object of InterLab logging infrastructure and represents a single (sub)task in a nested hierarchy.</p>"},{"location":"contexts/basics/#using-a-context-as-a-context-manager","title":"Using a Context as a context manager","text":"<p>To utilize a Context within your code, here's a pattern involving <code>with</code> statements:</p> <pre><code>from interlab.context import Context\n\nwith Context(\"my context\", inputs={\"x\": 42}) as c:\n    y = do_a_computation(x=42)\n    c.set_result(y)\n</code></pre>"},{"location":"contexts/basics/#hierarchically-nested-contexts","title":"Hierarchically Nested Contexts","text":"<p>Contexts can be nested to construct a clear hierarchy reflecting the structure of a complex computation:</p> <pre><code>with Context(\"root\") as root_ctx:\n    with Context(\"child-1\"):\n       with Context(\"child-1-1\"):\n           pass\n       with Context(\"child-1-2\"):\n           pass\n    with Context(\"child-2\"):\n       pass\n</code></pre> <p>If this context are visualized in Data Browser or in Jupyter notebook via <code>root_ctx.display()</code>:</p> <p></p>"},{"location":"contexts/basics/#context-states","title":"Context states","text":"<p>Throughout its lifetime, a context traverses several states:</p> <ul> <li>New -  Freshly instantiated Context</li> <li>Open - Running context</li> <li>Finished - Successfully finished context</li> <li>Error - Unsuccessfully finished context</li> </ul> <pre><code>ctx = Context(\"my context\")  # Context in NEW state\nwith ctx:\n    # Context in OPEN state\n    compute_something()\n# Context in FINISHED state\n</code></pre> <p>When an unhandled exception passes through a context boundary, it sets the context to the ERROR state. Example:</p> <pre><code>with Context(\"my context\"):\n    raise Exception(\"Something is wrong\")\n# Context in ERROR state\n</code></pre> <p>Alternatively, the <code>.set_error(error)</code> method can be called on context to explicitly set a context to the ERROR state.</p>"},{"location":"contexts/basics/#managing-inputs-and-results","title":"Managing Inputs and Results","text":"<p>Context may have one or more named inputs and at most one result</p> <pre><code>from interlab.context import Context\n\nwith Context(\"my context\", inputs={\"x\": 42}) as c: # Set inputs when context is created\n    c.add_inputs({\"y\": 123, \"z\": 321})  # Add inputs dynamically\n    c.set_result(\"my_result\")  # Set result explicitly\n</code></pre> <p>The name of the input has to be string.</p>"},{"location":"contexts/basics/#enhancing-functions-with-with_context","title":"Enhancing Functions with <code>with_context</code>","text":"<p>A function can be annotated with with_context decorator. It automatically creates a new context that captures inputs and the result when the function is called.</p> <pre><code>from interlab.context import with_context\n\n@with_context\ndef my_computation(x):\n    ...\n</code></pre>"},{"location":"contexts/basics/#events","title":"Events","text":"<p>An event is an instant context with immediate result and no child contexts.</p> <pre><code>with Context(\"root\") as c:\n    c.add_event(\"Message to Alice\", kind=\"message\", data=\"Hi, Alice!\")\n</code></pre>"},{"location":"contexts/basics/#tags","title":"Tags","text":"<p>Utilizing Tags</p> <p>Tags are custom identifiers attachable to any Context, facilitating subsequent filtering based on these tags. A tag is either directly a string or an instance of <code>Tag</code>.</p> <p>Tag appearances in the Data Browser can be customized with an associated HTML color:</p> <pre><code>from interlab.context import Context, Tag\n\nwith Context(\"root\", tags=[\"tag1\", Tag(\"tag2\")]) as ctx:\n    c.add_tag(\"exp1\")  # Add tag to a context dynamically\n    c.add_tag(Tag(\"success!\", color=\"lightgreen\"))  # Add a tag with custom color\n</code></pre>"},{"location":"contexts/basics/#attaching-meta-information","title":"Attaching Meta information","text":"<p>A meta information can be attached to every context. It is a dictionary with string keys. Keys and values may be user defined; however, some keys are recognized by DataBrowser and influences how the context is rendered.</p> <pre><code>with Context(\"root\", meta={\"key\": \"value\"}) as ctx:\n    pass\n</code></pre> <p>InterLab specifically recognizes and utilizes the following metadata keys, influencing the visual rendering in the Data Browser:</p> <ul> <li>\"color\": [HTML color] - Defines the main color of the Context. In the current version, it is used for the title of context and a line when context is expanded.</li> <li>\"color_bg\": [HTML color] - Sets the Context's background color.</li> <li>\"color_border\": [HTML color] - Draws a border with the specified color around the Context.</li> </ul>"},{"location":"contexts/databrowser/","title":"Data Browser","text":""},{"location":"contexts/databrowser/#static-and-dynamic-visualtion-of-contexts","title":"Static and dynamic visualtion of contexts","text":"<p>There two main ways how visualize a context:</p> <ul> <li>Static - creates a standalone HTML code that captures a snaphost of the current state of the context.   Visulation is not updated when context evolves.</li> <li>Dynamic (live) - it dynamically reflects the current state of the context. It needs a running storage server (Storage);</li> </ul>"},{"location":"contexts/databrowser/#static-view","title":"Static view","text":"<p>To create a static view you can call <code>.create_html(path)</code> that create a HTML file that contains a visualization of the context.</p> <p>In Jypter notebook you can directly call <code>.display()</code> on a context to create a static view on context that is immediately shown in Jupyter.</p>"},{"location":"contexts/databrowser/#live-data-browser-as-a-stand-alone-page","title":"Live data browser as a stand alone page","text":"<p>Live data browser works only when context is stored in a storage.</p> <p>Method <code>.start_server()</code> returns a handle where a HTTP server is running.</p> <pre><code>storage = FileStorage(\"./my-directory\")\nstorage.start_server()  # returns &lt;ServerHandle http://localhost:PORT&gt;\n</code></pre> <p>The Data browser is running on the given address. If you register the root context in the storage, e.g.:</p> <pre><code>with Context(\"my test\", storage=storage):\n    with Context(\"a child\"):\n        pass\n    with Context(\"a child\"):\n        pass\n</code></pre> <p>and refreshes the view (icon the following image) then a new context occurs</p> <p></p>"},{"location":"contexts/databrowser/#live-data-bbrowser-in-jupyter","title":"Live data bBrowser in Jupyter","text":"<p>In Jupyter notebook, a storage have a method <code>.live_display</code> that internally starts the server shows a Data Browser directly in Jupyter notebook.</p> <pre><code>storage = FileStorage(\"./my-directory\")\nstorage.live_display() # Shows Data browser in the resulting Jupyter output cell\n</code></pre>"},{"location":"contexts/databrowser/#embedded-html","title":"Embedded HTML","text":"<p>TODO</p>"},{"location":"contexts/databrowser/#data-with-mime-type","title":"Data with MIME type","text":"<p>TODO</p>"},{"location":"contexts/serialization/","title":"Serialization to JSON","text":"<p>Context can be serialized into JSON via to_dict method:</p> <pre><code>from interlab.context import Context\n\nwith Context(\"my context\", inputs={\"x\": 42}) as c:\n    c.set_result(\"my_result\")\n</code></pre> <p>Calling <code>c.to_dict()</code> returns:</p> <pre><code>{\n  \"_type\": \"Context\",\n  \"name\": \"my context\",\n  \"uid\": \"2023-08-23T16:41:35-my_context-Z9YpEb\",\n  \"inputs\": {\n    \"x\": 42\n  },\n  \"result\": \"my_result\",\n  \"start_time\": \"2023-08-23T16:41:35.811159\",\n  \"end_time\": \"2023-08-23T16:41:35.811210\"\n}\n</code></pre> <p>When inputs or a result are not directly serializable into JSON options are provided:</p>"},{"location":"contexts/serialization/#serialization-of-dataclasses","title":"Serialization of dataclasses","text":"<p>Dataclasses are serialized as <code>dict</code>:</p> <pre><code>@dataclass\nclass Person:\n    name: str\n    age: int\n\n@with_context\ndef say_hi(person):\n    return f\"Hi {person.name}!\"\n\nwith Context(\"root\") as c:\n    person = Person(\"Alice\", 21)\n    say_hi(person)\n</code></pre> <p>creates the following context:</p> <pre><code>{\n  \"_type\": \"Context\",\n  \"name\": \"root\",\n  \"uid\": \"2023-08-23T16:52:43-root-H4JCSN\",\n  \"children\": [\n    {\n      \"_type\": \"Context\",\n      \"name\": \"say_hi\",\n      \"uid\": \"2023-08-23T16:52:43-say_hi-GGfCCe\",\n      \"kind\": \"call\",\n      \"result\": \"Hi Alice!\",\n      \"inputs\": {                       \n        \"person\": {                     # &lt;&lt;&lt;&lt;\n          \"name\": \"Alice\",              # &lt;&lt;&lt;&lt;\n          \"age\": 21,                    # &lt;&lt;&lt;&lt;\n          \"_type\": \"Person\"             # &lt;&lt;&lt;&lt;\n        }\n      },\n      \"start_time\": \"2023-08-23T16:52:43.115548\",\n      \"end_time\": \"2023-08-23T16:52:43.115572\"\n    }\n  ],\n  \"start_time\": \"2023-08-23T16:52:43.115449\",\n  \"end_time\": \"2023-08-23T16:52:43.115585\"\n}\n</code></pre>"},{"location":"contexts/serialization/#method-__log_to_context__","title":"Method <code>__log_to_context__</code>","text":"<p>A user type may define method <code>__log_to_context__</code> to provide a custom serializer.</p> <pre><code>class Person:\n    name: str\n    age: int\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __log_to_context__(self):\n        return {\"name\": self.name, \"age\": self.age}\n\nperson = Person(\"Peter\", 24)\n</code></pre> <p>When <code>person</code> is serialized, the following dictionary is produced:</p> <pre><code>{\n    \"name\": \"Peter\",\n    \"age\": 24,\n    \"_type\": \"Person\"\n}\n</code></pre>"},{"location":"contexts/serialization/#registration-of-serializer","title":"Registration of serializer","text":"<p>Sometimes we do not or we cannot modify a class. Registration a serializer for a given type is there for this purpose.</p> <pre><code>    from interlab.context.serialization import register_custom_serializer\n\n    class MyClass:\n        def __init__(self, x):\n            self.x = x\n\n    def myclass_serializer(m: MyClass):\n        return {\"x\": m.x}\n\n    register_custom_serializer(MyClass, myclass_serializer)\n</code></pre>"},{"location":"contexts/serialization/#fallback","title":"Fallback","text":"<p>When no mechanism above is used then only name of the type and object <code>id</code> is serialized.</p> <p>E.g.: </p> <pre><code>{\n    \"_type\": \"Person\",\n    \"id\": 140263930622832\n}\n</code></pre>"},{"location":"contexts/storage/","title":"Storage","text":"<p>InterLab storage manages serialized contexts. The current implementation allows to store contexts as (compresed) files into a directory structure.</p>"},{"location":"contexts/storage/#basics","title":"Basics","text":"<p>Storage can be initialized by instantiating FileStorage</p> <pre><code>from interlab.context import FileStorage\n\nstorage = FileStorage(\"/path/to/a/directory\")\n</code></pre> <p>A context can be written manually as follows:</p> <pre><code>with Context(\"root\") as ctx:\n    pass\n\nstorage.write_context(ctx)\n</code></pre> <p>Or a context can be directly created with storage:</p> <pre><code>with Context(\"root\", storage=storage):\n    pass\n</code></pre> <p>The latter have advantage that context is known to the storage from the initialization and it is visible in Data Browser even in the running state. However, context is physically written into the persistent storage after the computation is finished.</p>"},{"location":"contexts/storage/#storage-and-with-block","title":"Storage and <code>with</code> block","text":"<p>Storage can be used as a context manager, in such a case all root contexts are automatically written  into the storage.</p> <pre><code>from interlab.context import FileStorage\n\nstorage = FileStorage(\"/path/to/a/directory\")\nwith storage:\n    with Context(\"root\"):\n        pass\n</code></pre>"},{"location":"contexts/storage/#directory","title":"Directory","text":"<p>By default a context is stored into a single file with all its children. If <code>directory</code> flag is set to <code>True</code> then context is stored as a directory and its children are stored in files in it (or sub-directories when a child has also <code>directory</code> flag). </p> <pre><code>with Context(\"root\", directory=True, storage=storage):  # &lt;-- Stored as a dictionary\n    with Context(\"child1\"):  # &lt;-- Stored as file\n        pass\n</code></pre>"},{"location":"contexts/storage/#loading-contexts","title":"Loading contexts","text":"<p>Contexts can be loaded from storage. </p> <pre><code># Read all stored (root) contexts\nfor context in storage.read_all_contexts():\n    ...\n\n# Recursively search for specific contexts\nfor context in storage.find_contexts(lambda ctx: ctx.has_tag_name(\"hello\")):\n    ...\n\n# Read a context by uid\ncontext = storage.read_context(uid)\n</code></pre>"}]}